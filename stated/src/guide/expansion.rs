//! Code generated by the macro.
//!
//! Stated makes some modifications and additions to your code behind the
//! scenes.
//!
//! **All macro expansions shown in this section are based on the following
//! code.**
//!
//! ```
//! # use stated::stated;
//! #
//! #[stated(states(A, B, C), preset(C))]
//! struct Example<#[stated] S> {
//!     x: i32,
//! }
//!
//! #[stated]
//! impl<#[stated] S> Example<S> {
//!     #[stated]
//!     fn new() -> Example<_> {
//!         Example { x: 0 }
//!     }
//!
//!     #[stated(reject(B), assign(A))]
//!     fn foo(mut self, x: i32) -> Example<_> {
//!         self.x = x;
//!         _
//!     }
//! }
//! ```
//!
//! # Struct
//!
//! The Stated macro modifies the struct definition and generates private helper
//! utilities for the struct.
//!
//! ## Phantom Field
//!
//! Stated inserts a hidden [`PhantomData`](std::marker::PhantomData) field into
//! your struct to represent its state. When you create an instance using a
//! struct literal inside an associated function, Stated automatically fills in
//! this field for you. For example, in `Example::new` only the `x` field is
//! explicitly set. The phantom field is set behind the scenes.
//!
//! ### Expansion
//!
//! ```
//! pub struct Example<S> {
//!     x: i32,
//!     __states: ::std::marker::PhantomData<S>,
//! }
//! ```
//!
//! ## Reconstruct Method
//!
//! A private method is added to assist with transitioning states. This
//! method replaces [inferred expressions](super::tutorial::syntax#infer) in the
//! method body.
//!
//! ### Expansion
//!
//! ```
//! # {} /*
//! impl<S> Example<S> {
//!     pub(crate) fn __reconstruct<__Re>(self) -> Example<__Re> {
//!         Example {
//!             x: self.x,
//!             __states: ::std::marker::PhantomData,
//!         }
//!     }
//! }
//! # */
//! ```
//!
//! ## Token Export Macro
//!
//! A private macro is defined to export all tokens from the struct definition
//! to the impl block.
//!
//! ### Expansion
//!
//! ```
//! #[doc(hidden)]
//! macro_rules! __Example {
//!     ($($tt:tt)*) => {
//!         #[::stated::stated_internal(states(A, B, C), preset(C))]
//!         $($tt)*
//!     }
//! }
//!
//! pub(crate) use __Example as Example;
//! ```
//!
//! # Impl and Impl Functions
//!
//! Stated modifies the impl block and associated functions to enforce and
//! transition states.
//!
//! ## Import Tokens
//!
//! All [exported](#token-export-macro) tokens from the struct definition are
//! imported to the impl block.
//!
//! ## Generics
//!
//! Stated modifies the generics of the impl block and associated function.
//!
//! ```
//! # {} /*
//! impl Example<::stated::__> {
//!     pub fn new() -> Example<(::stated::N, ::stated::N, ::stated::Y)> {
//!         ...
//!     }
//! }
//!
//! impl<A, C> Example<(A, ::stated::N, C)> {
//!     pub fn foo(mut self, x: i32) -> Example<(::stated::Y, ::stated::N, C)> {
//!         ...
//!     }
//! }
//! # */
//! ```
//!
//! ## Functions
//!
//! The [phantom field](#phantom-field) `__states` is set in the struct literal
//! in `Example::new`. In `Example::foo`, the [inferred
//! expression](super::tutorial::syntax#infer) is replaced with the [reconstruct
//! method](#reconstruct-method).
//!
//! ### Expansion
//!
//! ```
//! # {} /*
//! impl Example<::stated::__> {
//!     pub fn new() -> Example<(::stated::N, ::stated::N, ::stated::Y)> {
//!         Example {
//!             x: 0,
//!             __states: ::std::marker::PhantomData,
//!         }
//!     }
//! }
//!
//! impl<A, C> Example<(A, ::stated::N, C)> {
//!     pub fn foo(mut self, x: i32) -> Example<(::stated::Y, ::stated::N, C)> {
//!         self.x = x;
//!         self.__reconstruct()
//!     }
//! }
//! # */
//! ```
